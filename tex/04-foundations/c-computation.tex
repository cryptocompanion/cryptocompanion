\subsection{Model of computation}\label{ssec:model-of-computation}
To be able to express cryptographic statements precisely, we need a notion of runtime. The runtime of an algorithm is, essentially, the number of \emph{steps} needed to perform a computation. But what exactly is a step? And what is an algorithm?

There is a rich theory that invented various machine models (machine model = formalization of what an algorithm is) such as Turing Machines, Circuits, Random Access Machines etc. All of these models have in common that they build complex programs based on a fixed set of local operations that only operate on few bits of the current state of the machine, and they count one such operation as one step (see, e.g. \cite[Chapters 1.2.2 and 1.2.3]{goldreichcomplexity}). Using such models of computation is often cumbersome. Importantly, by the Church-Turing Thesis (see, e.g. \cite[Chapter 1.2.3]{goldreichcomplexity}), essentially all reasonable models are equivalent, so it does not really matter which one we choose (and you will be able to follow the course also if you have not seen any such models yet)---except that some models of computation are more easy to use than others.

One can see a programming language as a model of computation, too, and indeed, a nice programming language such as $F\sharp$ is much more usable than programming in Assembly or, even worse, programming Turing Machines on paper (a very cumbersome exercise which is sometimes requested in courses on computability).

In this course, instead of using a concrete programming language, we use \emph{pseudocode}. The pseudocode relies on the notation introduced in Section~\ref{section:definitions}, and additionally, we might define further functions as we go. The advantage of pseudocode over a real programming language is that the code is short, human-readeable, quite flexible and abstracts away further details. We sometimes define notation ad hoc as we go such when it is useful for the problem at hand. Such a liberal approach is common practice in mathematics but sometimes a little unusual in computer science. Using pseudocode is essentially a middle-ground between the liberal attitude of mathematicians and the syntactically strict attitude of computer scientists. We hope that using pseudocode strikes a balance that is accessible to both (and hopefully also to those studying neither mathematics nor computer science).

In the interest of simplicity, we define our pseudocode such that algorithms written in our pseudocode are guaranteed to terminate. In general, this weakens our notion of an algorithm as compared to, say, Turing Machines where it is known that deciding whether a Turing Machine halts or not is a hard problem\footnote{This problem, known as the \emph{Halting Problem}, is not merely hard, but, in fact, even \emph{undecidable}, i.e., it does not have an algorithm solution, not even an inefficient one, see, e.g. \cite[Chapters 1.2.3]{goldreichcomplexity}.}. However, in the context of this course we only consider  algorithms with a fixed upped bound on their runtime, so no generality is lost.